

# File: components/analytics/UserActivity.tsx
import React, { useState, useEffect } from 'react';
import { format } from 'date-fns';
import DateRangeSelector from '../common/DateRangeSelector';

interface UserActivityData {
  trace_id: string;
  email: string;
  firstAction: string;
  lastAction: string;
  daysBetween: number;
  totalActions: number;
}

const UserActivity: React.FC = () => {
  const [startDate, setStartDate] = useState<Date>(new Date('2024-01-27'));
  const [endDate, setEndDate] = useState<Date>(new Date());
  const [filterType, setFilterType] = useState<string>('consecutive_days');
  const [loading, setLoading] = useState<boolean>(true);
  const [users, setUsers] = useState<UserActivityData[]>([]);

  useEffect(() => {
    fetchUserActivity();
  }, [startDate, endDate, filterType]);

  const fetchUserActivity = async () => {
    try {
      setLoading(true);
      const response = await fetch(`/metrics/user-activity?startDate=${startDate.toISOString()}&endDate=${endDate.toISOString()}&filterType=${filterType}`);
      const data = await response.json();
      if (data.status === 'success') {
        setUsers(data.users);
      }
    } catch (error) {
      console.error('Error fetching user activity:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleDateChange = (start: Date, end: Date) => {
    setStartDate(start);
    setEndDate(end);
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-2xl font-bold text-gray-900">User Activity Analysis</h1>
      </div>

      <div className="mb-8 space-y-4">
        <DateRangeSelector
          startDate={startDate}
          endDate={endDate}
          onDateChange={handleDateChange}
        />

        <div className="flex gap-4">
          <button
            onClick={() => setFilterType('consecutive_days')}
            className={`px-4 py-2 rounded-md ${
              filterType === 'consecutive_days'
                ? 'bg-blue-600 text-white'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            Consecutive Days
          </button>
          <button
            onClick={() => setFilterType('one_to_two_weeks')}
            className={`px-4 py-2 rounded-md ${
              filterType === 'one_to_two_weeks'
                ? 'bg-blue-600 text-white'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            1-2 Weeks Apart
          </button>
          <button
            onClick={() => setFilterType('two_to_three_weeks')}
            className={`px-4 py-2 rounded-md ${
              filterType === 'two_to_three_weeks'
                ? 'bg-blue-600 text-white'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            2-3 Weeks Apart
          </button>
          <button
            onClick={() => setFilterType('month_apart')}
            className={`px-4 py-2 rounded-md ${
              filterType === 'month_apart'
                ? 'bg-blue-600 text-white'
                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
            }`}
          >
            Month Apart
          </button>
        </div>
      </div>

      {loading ? (
        <div className="flex justify-center items-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
        </div>
      ) : (
        <div className="bg-white rounded-lg shadow overflow-hidden">
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    User
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    First Action
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Last Action
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Days Between
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Total Actions
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {users.map((user, index) => (
                  <tr key={user.trace_id} className="hover:bg-gray-50">
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="text-sm text-gray-900">{user.email}</div>
                      <div className="text-sm text-gray-500">{user.trace_id}</div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {format(new Date(user.firstAction), 'MMM d, yyyy HH:mm')}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {format(new Date(user.lastAction), 'MMM d, yyyy HH:mm')}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {user.daysBetween}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {user.totalActions}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}
    </div>
  );
};

export default UserActivity;

# File: components/common/DateRangeSelector.tsx
import React from 'react';
import { format } from 'date-fns';

interface DateRangeSelectorProps {
  startDate: Date;
  endDate: Date;
  onDateChange: (start: Date, end: Date) => void;
}

const DateRangeSelector: React.FC<DateRangeSelectorProps> = ({
  startDate,
  endDate,
  onDateChange,
}) => {
  return (
    <div className="flex items-center gap-4">
      <div className="flex items-center gap-2">
        <label htmlFor="start-date" className="text-sm text-gray-600">
          From
        </label>
        <input
          id="start-date"
          type="date"
          className="border border-gray-300 rounded-md px-3 py-1.5 text-sm"
          value={format(startDate, 'yyyy-MM-dd')}
          onChange={(e) => {
            const newStart = new Date(e.target.value);
            onDateChange(newStart, endDate);
          }}
          max={format(endDate, 'yyyy-MM-dd')}
        />
      </div>
      <div className="flex items-center gap-2">
        <label htmlFor="end-date" className="text-sm text-gray-600">
          To
        </label>
        <input
          id="end-date"
          type="date"
          className="border border-gray-300 rounded-md px-3 py-1.5 text-sm"
          value={format(endDate, 'yyyy-MM-dd')}
          onChange={(e) => {
            const newEnd = new Date(e.target.value);
            onDateChange(startDate, newEnd);
          }}
          min={format(startDate, 'yyyy-MM-dd')}
          max={format(new Date(), 'yyyy-MM-dd')}
        />
      </div>
      <div className="flex gap-2">
        <button
          onClick={() => {
            const end = new Date();
            const start = new Date();
            start.setDate(end.getDate() - 7);
            onDateChange(start, end);
          }}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded-md"
        >
          Last 7 days
        </button>
        <button
          onClick={() => {
            const end = new Date();
            const start = new Date();
            start.setDate(end.getDate() - 30);
            onDateChange(start, end);
          }}
          className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded-md"
        >
          Last 30 days
        </button>
      </div>
    </div>
  );
};

export default DateRangeSelector;

# File: components/dashboard/Dashboard.tsx
import React, { useState, useEffect } from 'react';
import MetricGrid from '../metrics/MetricGrid';
import DateRangeSelector from '../common/DateRangeSelector';
import UserTable from '../users/UserTable';
import { fetchMetrics } from '../../services/metricService';
import { Metric } from '../../types/metrics';

const Dashboard: React.FC = () => {
  const [metrics, setMetrics] = useState<Metric[]>([]);
  const [startDate, setStartDate] = useState<Date>(new Date(Date.now() - 30 * 24 * 60 * 60 * 1000));
  const [endDate, setEndDate] = useState<Date>(new Date());
  const [includeV1, setIncludeV1] = useState<boolean>(true);
  const [selectedMetric, setSelectedMetric] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    loadMetrics();
  }, [startDate, endDate, includeV1]);

  const loadMetrics = async () => {
    try {
      setLoading(true);
      const response = await fetchMetrics(startDate, endDate, includeV1);
      setMetrics(response.metrics);
    } catch (error) {
      console.error('Error loading metrics:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleMetricClick = (metricId: string) => {
    setSelectedMetric(metricId);
  };

  const handleDateChange = (start: Date, end: Date) => {
    setStartDate(start);
    setEndDate(end);
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex flex-col space-y-4 mb-8">
        <h1 className="text-2xl font-bold text-gray-900">Analytics Dashboard</h1>
        <div className="flex flex-wrap gap-4 items-center">
          <label className="flex items-center space-x-2 min-w-[150px]">
            <input
              type="checkbox"
              checked={includeV1}
              onChange={(e) => setIncludeV1(e.target.checked)}
              className="form-checkbox h-4 w-4 text-blue-600"
            />
            <span className="text-sm text-gray-700">Include V1</span>
          </label>
          <div className="flex-grow">
            <DateRangeSelector
              startDate={startDate}
              endDate={endDate}
              onDateChange={handleDateChange}
            />
          </div>
        </div>
      </div>

      {loading ? (
        <div className="flex justify-center items-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
        </div>
      ) : (
        <>
          <MetricGrid metrics={metrics} onMetricClick={handleMetricClick} />
          {selectedMetric && (
            <UserTable 
              gaugeType={selectedMetric}
              timeRange={{
                start: startDate,
                end: endDate
              }}
            />
          )}
        </>
      )}
    </div>
  );
};

export default Dashboard;

# File: components/layout/Layout.tsx
// src/components/layout/Layout.tsx
import React from 'react'
import Navbar from './Navbar'
import Sidebar from './Sidebar'

interface LayoutProps {
  children: React.ReactNode
}

const Layout = ({ children }: LayoutProps) => {
  return (
    <div className="min-h-screen flex flex-col">
      <Navbar />
      <div className="flex flex-1 pt-16">
        <Sidebar />
        <main className="flex-1 ml-64 bg-gray-50 p-8">
          <div className="max-w-7xl mx-auto">
            {children}
          </div>
        </main>
      </div>
    </div>
  )
}

export default Layout

# File: components/layout/Navbar.tsx
// src/components/layout/Navbar.tsx
import React from 'react'
import { Menu } from 'lucide-react'

const Navbar = () => {
  return (
    <header className="fixed top-0 left-0 right-0 h-16 bg-white border-b border-gray-200 z-30">
      <div className="h-full mx-auto px-4">
        <div className="h-full flex items-center justify-between">
          <span className="text-lg font-semibold text-gray-900">
            Analytics Dashboard
          </span>
          <button 
            type="button"
            className="p-1.5 rounded-md text-gray-400 hover:text-gray-500 transition-colors"
          >
            <Menu size={18} />
          </button>
        </div>
      </div>
    </header>
  )
}

export default Navbar

# File: components/layout/Sidebar.tsx
// src/components/layout/Sidebar.tsx
import React, { useState, useEffect } from 'react'
import { Home, BarChart2, Users, Activity } from 'lucide-react'
import { useNavigate, useLocation } from 'react-router-dom'

const navigation = [
  { name: 'Overview', icon: Home, path: '/dashboard' },
  { name: 'Analytics', icon: BarChart2, path: '/dashboard' },
  { name: 'Users', icon: Users, path: '/dashboard' },
  { name: 'User Activity', icon: Activity, path: '/user-activity' },
]

const Sidebar = () => {
  const navigate = useNavigate()
  const location = useLocation()
  const [selected, setSelected] = useState(navigation[0].name)

  useEffect(() => {
    const currentPath = location.pathname
    const currentNav = navigation.find(nav => nav.path === currentPath)
    if (currentNav) {
      setSelected(currentNav.name)
    }
  }, [location])
  
  const handleNavigation = (item: typeof navigation[0]) => {
    setSelected(item.name)
    navigate(item.path)
  }
  
  return (
    <aside className="fixed top-16 left-0 w-64 h-[calc(100vh-4rem)] bg-white border-r border-gray-200">
      <nav className="h-full py-4">
        <div className="px-3 space-y-1">
          {navigation.map((item) => {
            const Icon = item.icon
            const isActive = selected === item.name
            
            return (
              <button
                key={item.name}
                onClick={() => handleNavigation(item)}
                className={`
                  flex items-center w-full px-3 py-2 text-sm rounded-md
                  ${isActive 
                    ? 'bg-gray-100 text-gray-900 font-medium' 
                    : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900'}
                `}
              >
                <Icon 
                  size={18} 
                  className="mr-3 flex-shrink-0" 
                />
                {item.name}
              </button>
            )
          })}
        </div>
      </nav>
    </aside>
  )
}

export default Sidebar

# File: components/metrics/MetricCard.tsx
import React from 'react';
import { ArrowUpIcon, ArrowDownIcon } from '@heroicons/react/24/solid';
import { Metric } from '../../types/metrics';

interface MetricCardProps {
  metric: Metric;
  onClick?: () => void;
}

const MetricCard: React.FC<MetricCardProps> = ({ metric, onClick }) => {
  const { name, description, data } = metric;
  const showV1Data = metric.id === 'descope_users' || metric.id === 'thread_users';

  const formatNumber = (num: number | undefined) => {
    if (!num && num !== 0) return '0';
    if (num >= 1000000) {
      return `${(num / 1000000).toFixed(1)}M`;
    }
    if (num >= 1000) {
      return `${(num / 1000).toFixed(1)}k`;
    }
    return num.toString();
  };

  const getTrendIcon = () => {
    if (data.trend === 'up') {
      return <ArrowUpIcon className="h-4 w-4 text-green-500" />;
    }
    if (data.trend === 'down') {
      return <ArrowDownIcon className="h-4 w-4 text-red-500" />;
    }
    return null;
  };

  const getTotalValue = () => {
    const baseValue = data.value || 0;
    if (!showV1Data || !data.v1Value) {
      return baseValue;
    }
    return baseValue + data.v1Value;
  };

  const getValue = () => {
    return data.value !== undefined ? data.value : null;
  };

  return (
    <div 
      className="bg-white rounded-lg shadow-md p-6 cursor-pointer hover:shadow-lg transition-shadow"
      onClick={onClick}
    >
      <div className="flex flex-col space-y-2">
        <div className="flex justify-between items-start">
          <div>
            <h3 className="text-lg font-semibold text-gray-900">{name}</h3>
            <p className="text-sm text-gray-500">{description}</p>
          </div>
          <div className="flex items-center space-x-1">
            {getTrendIcon()}
          </div>
        </div>
        
        <div className="mt-4">
          <div className="flex flex-col">
            <div className="text-4xl font-bold text-gray-900">
              {formatNumber(getValue())}
            </div>
            {showV1Data && data.v1Value !== undefined && data.v1Value > 0 && (
              <div className="mt-2 flex flex-col">
                <div className="text-sm text-gray-500">
                  With V1: {formatNumber(getTotalValue())}
                </div>
                <div className="text-xs text-gray-400">
                  (V1: +{formatNumber(data.v1Value)})
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default MetricCard;

# File: components/metrics/MetricGrid.tsx
import { FC } from 'react'
import { Metric } from '../../types/metrics'
import MetricCard from './MetricCard'

interface MetricGridProps {
  metrics: Metric[]
  onMetricClick: (metricId: string) => void
  includeV1?: boolean
}

const MetricGrid: FC<MetricGridProps> = ({ metrics, onMetricClick, includeV1 = true }) => {
  // Define the order of metrics and their display names
  const orderedMetricIds = [
    'descope_users',
    'thread_users',
    'render_users',
    'active_chat_users',
    'medium_chat_users',
    'sketch_users'
  ]

  // Custom display names and descriptions
  const displayConfig: { [key: string]: { name: string; description: string } } = {
    'descope_users': {
      name: 'Total Users',
      description: 'Total number of registered users'
    },
    'thread_users': {
      name: 'Active Users',
      description: 'Users who have started at least one message thread'
    },
    'render_users': {
      name: 'Producers',
      description: 'Users who have completed at least one render'
    },
    'active_chat_users': {
      name: 'Power Users',
      description: 'Users with more than 20 message threads'
    },
    'medium_chat_users': {
      name: 'Moderate Users',
      description: 'Users with 5-20 message threads'
    },
    'sketch_users': {
      name: 'Producers Attempting',
      description: 'Users who have uploaded at least one sketch'
    }
  }

  // Order and transform the metrics
  const orderedMetrics = orderedMetricIds
    .map(id => {
      const metric = metrics.find(m => m.id === id)
      if (!metric) return null

      return {
        ...metric,
        name: displayConfig[id]?.name || metric.name,
        description: displayConfig[id]?.description || metric.description
      }
    })
    .filter(Boolean)

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {orderedMetrics.map(metric => (
        <MetricCard
          key={metric!.id}
          metric={metric!}
          onClick={metric!.id !== 'descope_users' ? () => onMetricClick(metric!.id) : undefined}
          includeV1={includeV1}
        />
      ))}
    </div>
  )
}

export default MetricGrid

# File: components/users/UserTable.tsx
import React, { useState, useEffect } from 'react';
import { fetchUserStats } from '../../services/metricService';
import UserEventsModal from '../modal/UserEventsModal';

export interface UserStats {
  email: string;
  trace_id: string;
  messageCount: number;
  sketchCount: number;
  renderCount: number;
}

interface UserTableProps {
  gaugeType?: 'thread_users' | 'sketch_users' | 'render_users' | 'medium_chat_users' | 'active_chat_users';
  timeRange?: {
    start: Date;
    end: Date;
  };
}

const UserTable: React.FC<UserTableProps> = ({ gaugeType = 'thread_users', timeRange }) => {
  const [users, setUsers] = useState<UserStats[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string>('');
  const [selectedUserId, setSelectedUserId] = useState<string | null>(null);
  const [sortConfig, setSortConfig] = useState<{
    key: keyof UserStats;
    direction: 'ascending' | 'descending';
  }>({ key: 'messageCount', direction: 'descending' });

  useEffect(() => {
    const fetchData = async () => {
      if (!timeRange) return;

      try {
        setLoading(true);
        setError('');
        const data = await fetchUserStats(timeRange.start, timeRange.end, gaugeType);
        setUsers(data);
      } catch (err) {
        setError('Error fetching user statistics');
        console.error('Error fetching users:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [gaugeType, timeRange]);

  const handleSort = (key: keyof UserStats) => {
    setSortConfig(current => ({
      key,
      direction: current.key === key && current.direction === 'ascending' 
        ? 'descending' 
        : 'ascending'
    }));
  };

  const handleUserClick = (userId: string) => {
    setSelectedUserId(userId);
  };

  const handleCloseModal = () => {
    setSelectedUserId(null);
  };

  const sortedUsers = [...users].sort((a, b) => {
    if (sortConfig.direction === 'ascending') {
      return a[sortConfig.key] > b[sortConfig.key] ? 1 : -1;
    }
    return a[sortConfig.key] < b[sortConfig.key] ? 1 : -1;
  });

  const getSortIcon = (key: keyof UserStats) => {
    if (sortConfig.key !== key) return '↕️';
    return sortConfig.direction === 'ascending' ? '↑' : '↓';
  };

  const getTableTitle = () => {
    switch (gaugeType) {
      case 'thread_users':
        return 'Thread Users';
      case 'sketch_users':
        return 'Sketch Users';
      case 'render_users':
        return 'Render Users';
      case 'medium_chat_users':
        return 'Medium Chat Users';
      case 'active_chat_users':
        return 'Power Users';
      default:
        return 'Users';
    }
  };

  const columns = [
    {
      key: 'email' as keyof UserStats,
      label: 'Email',
      sortable: true
    },
    {
      key: 'messageCount' as keyof UserStats,
      label: 'Messages',
      sortable: true
    },
    {
      key: 'sketchCount' as keyof UserStats,
      label: 'Sketches',
      sortable: true
    },
    {
      key: 'renderCount' as keyof UserStats,
      label: 'Renders',
      sortable: true
    },
    {
      key: 'trace_id' as keyof UserStats,
      label: 'ID',
      sortable: false
    }
  ];

  return (
    <div className="mt-8 bg-white rounded-lg shadow">
      <div className="px-6 py-4 border-b border-gray-200">
        <h2 className="text-xl font-semibold text-gray-800">{getTableTitle()} Statistics</h2>
      </div>
      
      {loading && (
        <div className="flex justify-center items-center py-8">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
        </div>
      )}
      
      {error && (
        <div className="text-red-500 p-4 text-center bg-red-50">
          {error}
        </div>
      )}
      
      {!loading && !error && users.length === 0 && (
        <div className="text-gray-500 text-center py-8">
          No user statistics available
        </div>
      )}
      
      {users.length > 0 && (
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                {columns.map(column => (
                  <th 
                    key={column.key}
                    className={`px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider ${
                      column.sortable ? 'cursor-pointer hover:bg-gray-100' : ''
                    }`}
                    onClick={() => column.sortable && handleSort(column.key)}
                  >
                    {column.label} {column.sortable && getSortIcon(column.key)}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {sortedUsers.map((user, index) => (
                <tr 
                  key={user.trace_id || index}
                  className="hover:bg-gray-50 transition-colors duration-150 ease-in-out cursor-pointer"
                  onClick={() => handleUserClick(user.trace_id)}
                >
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="text-sm text-blue-600 hover:text-blue-800">
                      {user.email}
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="text-sm text-gray-900">{user.messageCount}</div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="text-sm text-gray-900">{user.sketchCount}</div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="text-sm text-gray-900">{user.renderCount}</div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="text-sm text-gray-500">{user.trace_id}</div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {selectedUserId && (
        <UserEventsModal
          userId={selectedUserId}
          onClose={handleCloseModal}
        />
      )}
    </div>
  );
};

export default UserTable;

# File: services/metricService.ts
import axios from 'axios';
import { MetricResponse, Metric, UserStats } from '../types/metrics';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:5001';

export const fetchMetrics = async (
  startDate: Date,
  endDate: Date,
  includeV1: boolean = true
): Promise<MetricResponse> => {
  try {
    const response = await axios.get(`${API_URL}/metrics`, {
      params: {
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString(),
        includeV1
      }
    });

    if (!response.data || !response.data.metrics) {
      throw new Error('Invalid response format from backend');
    }

    const metrics: Metric[] = response.data.metrics.map((metric: any) => ({
      id: metric.id,
      name: metric.name,
      description: metric.description,
      category: metric.category,
      interval: metric.interval,
      data: {
        value: metric.data.value !== undefined ? Number(metric.data.value) : undefined,
        previousValue: metric.data.previousValue !== undefined ? Number(metric.data.previousValue) : undefined,
        trend: metric.data.trend || 'neutral',
        changePercentage: metric.data.changePercentage,
        v1Value: metric.data.v1Value !== undefined ? Number(metric.data.v1Value) : undefined
      }
    }));

    return {
      metrics,
      timeRange: {
        start: new Date(response.data.timeRange.start),
        end: new Date(response.data.timeRange.end)
      }
    };

  } catch (error) {
    console.error('Error fetching metrics:', error);
    const defaultMetrics: Metric[] = [
      'descope_users',
      'thread_users',
      'render_users',
      'active_chat_users',
      'medium_chat_users',
      'sketch_users'
    ].map(id => ({
      id,
      name: id.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '),
      description: 'Error loading data',
      category: id.includes('chat') || id === 'thread_users' ? 'engagement' : 'user',
      interval: 'daily',
      data: {
        value: 0,
        trend: 'neutral',
        changePercentage: 0
      }
    }));

    return {
      metrics: defaultMetrics,
      timeRange: { start: startDate, end: endDate }
    };
  }
};

export const fetchUserStats = async (
  startDate: Date,
  endDate: Date,
  gaugeType: string
): Promise<UserStats[]> => {
  try {
    const response = await axios.get<{ status: string; data: UserStats[] }>(`${API_URL}/metrics/user-stats`, {
      params: {
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString(),
        gaugeType
      }
    });

    if (response.data.status === 'success' && Array.isArray(response.data.data)) {
      return response.data.data;
    }
    return [];
  } catch (error) {
    console.error('Error fetching user statistics:', error);
    return [];
  }
};

export interface UserEvent {
  event_name: string;
  timestamp: string;
  trace_id: string;
  flow_id?: string;
  [key: string]: any;
}

export interface UserEventsResponse {
  status: string;
  data: UserEvent[];
  timeRange: {
    start: string;
    end: string;
  };
}

export const fetchUserEvents = async (
  userId: string,
  startDate: Date = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
  endDate: Date = new Date()
): Promise<UserEventsResponse> => {
  try {
    const response = await axios.get<UserEventsResponse>(`${API_URL}/metrics/user-events`, {
      params: { 
        traceId: userId,
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString()
      }
    });

    if (response.data.status !== 'success' || !Array.isArray(response.data.data)) {
      throw new Error('Invalid response format from backend');
    }

    return response.data;
  } catch (error) {
    console.error('Error fetching user events:', error);
    throw error;
  }
};

# File: types/metrics.ts
export interface MetricValue {
  value: number;
  previousValue?: number;
  trend?: 'up' | 'down' | 'neutral';
  changePercentage?: number;
  v1Value?: number;
}

export interface Metric {
  id: string;
  name: string;
  description: string;
  category: 'user' | 'engagement' | 'performance';
  interval: 'daily' | 'weekly' | 'monthly';
  data: MetricValue;
}

export interface MetricResponse {
  metrics: Metric[];
  timeRange: {
    start: Date;
    end: Date;
  };
}

export interface UserStats {
  email: string;
  trace_id: string;
  messageCount: number;
  sketchCount: number;
  renderCount: number;
}

# File: utils/App.tsx
# Error: File not found - utils/App.tsx
